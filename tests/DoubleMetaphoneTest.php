<?php
/**
 * dblmetaphone
 *
 * @package     dblmetaphone
 * @author      Adrian Green
 * @copyright   Copyright (c) 2021
 */
declare(strict_types=1);

use AdrianGreen\Phonetic\DoubleMetaphone;
use AdrianGreen\Phonetic\DoubleMetaphoneResult;
use PHPUnit\Framework\IncompleteTestError;
use PHPUnit\Framework\TestCase;

class DoubleMetaphoneTest extends TestCase
{


    public function dataProviderForTestDoubleMetaphoneResultJson(): array
    {
        return [
            [
                'size'     => 4,
                'value'    => 'Eckhardt',
                'expected' => '{"value":"ECKHARDT","primary":"AKRT","alternate":"AKRT"}'
            ],
            [
                'size'     => 6,
                'value'    => 'Wolfeschlegelsteinhausenbergerdorff',
                'expected' => '{"value":"WOLFESCHLEGELSTEINHAUSENBERGERDORFF","primary":"ALFXLJ","alternate":"FLFXLK"}'
            ]
        ];
    }

    /**
     * @dataProvider dataProviderForTestDoubleMetaphoneResultJson
     */
    public function testDoubleMetaphoneResultJson(int $size, string $value, string $expected): void
    {
        $this->assertSame($expected, (new DoubleMetaphone($size))->getDoubleMetaphoneResult($value)->toJson());
    }

    /**
     * @dataProvider dataProviderForTestDoubleMetaphoneResultJson
     */
    public function testDoubleMetaphoneResultValidJson(int $size, string $value, string $expected): void
    {
        $this->assertJson((new DoubleMetaphone($size))->getDoubleMetaphoneResult($value)->toJson(), "Result is not JSON");
    }

    /**
     * @dataProvider dataProviderForTestDoubleMetaphoneResultJson
     */
    public function testDoubleMetaphoneResultSetValue(int $size, string $value, string $expected): void
    {
        $dmr = new DoubleMetaphoneResult();
        $dmr->setValue($value);
        $json = \json_decode($dmr->toJson(), true);
        $this->assertSame($value, $json['value']);
    }

    /**
     * Data Provider method uses reflection to be supplied with params
     * Yields data.
     * @param string $caller
     *
     * @return array
     */
    public function dataProviderForTestDoubleMetaphoneWords(string $caller): iterable
    {
        $doc = (new \ReflectionMethod(self::class, $caller))->getDocComment();
        \preg_match_all('#@(.*?)\n#s', $doc, $annotations);
        $supplied_annotations = [];
        if ($annotations) {
            $annotations = $annotations[1];
            foreach ($annotations as $annotation) {
                $tmp = \preg_split('/\s+/', trim($annotation));

                $supplied_annotations[\strtolower($tmp[0])] = $tmp[1];
            }
        }
        if (!isset($supplied_annotations['size']) || !\is_numeric($supplied_annotations['size'])) {
            throw new IncompleteTestError("Calling method MUST supply a @size n annotation");
        }
        $size = $supplied_annotations['size'];

        if (empty($supplied_annotations['filename'])) {
            throw new IncompleteTestError('Calling method MUST supply a @filename xxx annotation');
        }
        $filename = $supplied_annotations['filename'];

        /** Include data generated by the same Java implementation on which this is based */
        /* [word, primary_word, alternate_word] */
        /** @var array $testData */
        $test_file = __DIR__ . "/$filename-$size.php";
        if (!\file_exists($test_file)) {
            throw new IncompleteTestError("$test_file does not exist.");
        }
        $testData = require $test_file;
        /* [firstName, lastName, primary_firstName, alternate_firstName, primary_lastName, alternate_lastName] */
        foreach ($testData as $testSet) {
            yield [
                'word'           => $testSet[0],
                'primary_word'   => $testSet[1],
                'alternate_word' => $testSet[2],
            ];
        }
    }

    /**
     * @size 4
     * @filename words
     * @dataProvider dataProviderForTestDoubleMetaphoneWords
     */
    public function testDoubleMetaphoneWords_Size_4(string $word, string $primary, string $alternate): void
    {

        $this->assertSame($primary, (new DoubleMetaphone(4))->doubleMetaphone($word, false), $word);
    }
    /**
     * @size 6
     * @filename words
     * @dataProvider dataProviderForTestDoubleMetaphoneWords
     */
    public function testDoubleMetaphoneWords_Size_6(string $word, string $primary, string $alternate): void
    {

        $this->assertSame($primary, (new DoubleMetaphone(6))->doubleMetaphone($word, false), $word);
    }
    /**
     * @size 8
     * @filename words
     * @dataProvider dataProviderForTestDoubleMetaphoneWords
     */
    public function testDoubleMetaphoneWords_Size_8(string $word, string $primary, string $alternate): void
    {

        $this->assertSame($primary, (new DoubleMetaphone(8))->doubleMetaphone($word, false), $word);
    }

    public function testDoubleMetaphoneMethodCleanInputWhenEmpty(): void
    {
        $this->assertEmpty($this->callInaccessibleMethod(new DoubleMetaphone(), 'cleanInput', ''));
    }

    public function testGetDoubleMetaphoneResultWithEmptyValue(): void
    {
        $this->assertEmpty((new DoubleMetaphone())->getDoubleMetaphoneResult('')->getPrimary());
    }

    public function testIsDoubleMetaphoneEqual(): void
    {
        $this->assertFalse((new DoubleMetaphone(8))->isDoubleMetaphoneEqual('test string', 'another string'));
    }

    public function testDoubleMetaphoneEmptyGivesEmpty(): void
    {
        $this->assertEmpty((new DoubleMetaphone())->doubleMetaphone('', false));
    }
    
    public function testGetSetMaxCodeLength(): void
    {
        $dm = new DoubleMetaphone();
        $dm->setMaxCodeLen(7);
        $this->assertSame(7, $dm->getMaxCodeLen());
        
    }
     /**
      * Changes visibility of supplied method to public at runtime and invokes it.
      * @param object $object
      * @param string $method
      * @param array $parameters
      * @return mixed
      * @throws \Exception
      */
    private function callInaccessibleMethod(object $object, string $method , ...$parameters)
    {
        try {
            $className = get_class($object);
            $reflection = new \ReflectionClass($className);
        } catch (\ReflectionException $e) {
            throw new \RuntimeException($e->getMessage());
        }

        $method = $reflection->getMethod($method);
        $method->setAccessible(true);

        return $method->invokeArgs($object, $parameters);
    }
}
